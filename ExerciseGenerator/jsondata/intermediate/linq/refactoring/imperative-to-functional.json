{
  "metadata": {
    "id": "linq-imperative-to-functional-intermediate",
    "title": "Refactorizar Código Imperativo a Funcional con LINQ",
    "level": "Intermediate",
    "topic": "LINQ",
    "type": "Refactoring",
    "context": "ImperativeToFunctional",
    "estimatedMinutes": 45,
    "complexityScore": 6,
    "tags": ["linq", "functional-programming", "refactoring", "collections", "performance"],
    "version": "1.0",
    "lastUpdated": "2025-01-25T14:45:00Z"
  },
  "content": {
    "description": "Refactorizar código imperativo que utiliza bucles tradicionales, condicionales anidados y manipulación manual de colecciones hacia un enfoque funcional usando LINQ. Este ejercicio te ayudará a practicar métodos de LINQ (Where, Select, GroupBy, OrderBy), programación funcional vs imperativa, optimización de código con expresiones lambda, y manejo eficiente de colecciones grandes.",
    "learningObjectives": [
      "Convertir bucles foreach y for a operaciones LINQ equivalentes",
      "Reemplazar condicionales anidados con métodos Where y Any/All",
      "Usar Select para transformar datos en lugar de bucles manuales",
      "Aplicar GroupBy y agregaciones para reemplazar lógica de agrupamiento manual",
      "Optimizar rendimiento usando evaluación perezosa de LINQ",
      "Combinar múltiples operaciones LINQ en cadenas fluidas"
    ],
    "prerequisites": [
      "Comprensión sólida de bucles y estructuras de control",
      "Conocimiento básico de colecciones genéricas (List<T>, Dictionary<T,K>)",
      "Familiaridad con conceptos de programación orientada a objetos",
      "Entendimiento básico de expresiones lambda y delegates"
    ],
    "problemStatement": "Tienes un sistema de gestión de ventas que utiliza código imperativo tradicional con múltiples bucles anidados, validaciones manuales y construcción de colecciones paso a paso. El código funciona pero es verboso, difícil de leer y mantener.\n\nTu tarea es refactorizar este código imperativo hacia un estilo funcional usando LINQ, manteniendo exactamente la misma funcionalidad pero mejorando:\n\n1. **Legibilidad**: Código más conciso y expresivo\n2. **Mantenibilidad**: Lógica más clara y menos anidada\n3. **Rendimiento**: Aprovechamiento de evaluación perezosa\n4. **Testabilidad**: Separación de lógica en operaciones más pequeñas\n\nEl sistema debe procesar ventas, calcular estadísticas, filtrar datos y generar reportes usando operaciones LINQ en lugar de bucles manuales.",
    "technicalRequirements": [
      "Reemplazar todos los bucles foreach/for con operaciones LINQ apropiadas",
      "Eliminar variables temporales innecesarias usando cadenas de operaciones",
      "Usar métodos LINQ como Where, Select, GroupBy, OrderBy, Sum, Average",
      "Mantener el mismo comportamiento y resultados exactos",
      "Implementar manejo de casos edge (colecciones vacías, valores null)",
      "Optimizar performance evitando múltiples enumeraciones"
    ],
    "successCriteria": [
      "El código refactorizado produce resultados idénticos al original",
      "Se eliminan todos los bucles manuales en favor de operaciones LINQ",
      "El código es más conciso (menos líneas) sin sacrificar claridad",
      "Se utilizan al menos 5 métodos LINQ diferentes apropiadamente",
      "No hay múltiples enumeraciones de la misma colección",
      "El código maneja casos edge correctamente",
      "Las expresiones lambda son claras y expresivas"
    ],
    "instructions": "1. Analiza el código imperativo y identifica patrones que pueden beneficiarse de LINQ\n2. Refactoriza la lógica de filtrado usando Where en lugar de bucles con if\n3. Convierte transformaciones de datos usando Select\n4. Reemplaza lógica de agrupamiento manual con GroupBy\n5. Optimiza cálculos usando métodos de agregación (Sum, Average, Max, Min)\n6. Combina operaciones en cadenas fluidas donde sea apropiado\n7. Valida que los resultados sean idénticos ejecutando ambas versiones"
  },
  "code": {
    "beforeCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// CÓDIGO IMPERATIVO - NECESITA REFACTORING\n// Este código usa patrones imperativos tradicionales que pueden beneficiarse de LINQ\n\npublic class SaleRecord\n{\n    public int Id { get; set; }\n    public string CustomerName { get; set; } = \"\";\n    public string Product { get; set; } = \"\";\n    public decimal Amount { get; set; }\n    public DateTime SaleDate { get; set; }\n    public string Region { get; set; } = \"\";\n    public string SalesPersonId { get; set; } = \"\";\n}\n\npublic class SalesReportGenerator\n{\n    public static void GenerateReport(List<SaleRecord> sales)\n    {\n        Console.WriteLine(\"=== Reporte de Ventas (Código Imperativo) ===\");\n        \n        // 1. Filtrar ventas del último mes (IMPERATIVO)\n        List<SaleRecord> recentSales = new List<SaleRecord>();\n        DateTime lastMonth = DateTime.Now.AddMonths(-1);\n        \n        foreach (var sale in sales)\n        {\n            if (sale.SaleDate >= lastMonth)\n            {\n                recentSales.Add(sale);\n            }\n        }\n        \n        Console.WriteLine($\"Ventas del último mes: {recentSales.Count}\");\n        \n        // 2. Calcular total de ventas por región (IMPERATIVO)\n        Dictionary<string, decimal> salesByRegion = new Dictionary<string, decimal>();\n        \n        foreach (var sale in recentSales)\n        {\n            if (salesByRegion.ContainsKey(sale.Region))\n            {\n                salesByRegion[sale.Region] += sale.Amount;\n            }\n            else\n            {\n                salesByRegion[sale.Region] = sale.Amount;\n            }\n        }\n        \n        Console.WriteLine(\"\\nVentas por región:\");\n        foreach (var kvp in salesByRegion)\n        {\n            Console.WriteLine($\"  {kvp.Key}: ${kvp.Value:N2}\");\n        }\n        \n        // 3. Encontrar top 5 productos más vendidos (IMPERATIVO)\n        Dictionary<string, int> productCounts = new Dictionary<string, int>();\n        \n        foreach (var sale in recentSales)\n        {\n            if (productCounts.ContainsKey(sale.Product))\n            {\n                productCounts[sale.Product]++;\n            }\n            else\n            {\n                productCounts[sale.Product] = 1;\n            }\n        }\n        \n        // Ordenar manualmente\n        List<KeyValuePair<string, int>> sortedProducts = new List<KeyValuePair<string, int>>();\n        foreach (var kvp in productCounts)\n        {\n            sortedProducts.Add(kvp);\n        }\n        \n        // Bubble sort (ineficiente pero imperativo)\n        for (int i = 0; i < sortedProducts.Count - 1; i++)\n        {\n            for (int j = 0; j < sortedProducts.Count - i - 1; j++)\n            {\n                if (sortedProducts[j].Value < sortedProducts[j + 1].Value)\n                {\n                    var temp = sortedProducts[j];\n                    sortedProducts[j] = sortedProducts[j + 1];\n                    sortedProducts[j + 1] = temp;\n                }\n            }\n        }\n        \n        Console.WriteLine(\"\\nTop 5 productos más vendidos:\");\n        int count = 0;\n        foreach (var product in sortedProducts)\n        {\n            if (count >= 5) break;\n            Console.WriteLine($\"  {product.Key}: {product.Value} ventas\");\n            count++;\n        }\n        \n        // 4. Calcular promedio de ventas por vendedor (IMPERATIVO)\n        Dictionary<string, List<decimal>> salesBySalesPerson = new Dictionary<string, List<decimal>>();\n        \n        foreach (var sale in recentSales)\n        {\n            if (!salesBySalesPerson.ContainsKey(sale.SalesPersonId))\n            {\n                salesBySalesPerson[sale.SalesPersonId] = new List<decimal>();\n            }\n            salesBySalesPerson[sale.SalesPersonId].Add(sale.Amount);\n        }\n        \n        Console.WriteLine(\"\\nPromedio de ventas por vendedor:\");\n        foreach (var kvp in salesBySalesPerson)\n        {\n            decimal total = 0;\n            int count2 = 0;\n            foreach (var amount in kvp.Value)\n            {\n                total += amount;\n                count2++;\n            }\n            decimal average = count2 > 0 ? total / count2 : 0;\n            Console.WriteLine($\"  {kvp.Key}: ${average:N2}\");\n        }\n        \n        // 5. Encontrar ventas grandes (>$1000) y ordenar (IMPERATIVO)\n        List<SaleRecord> largeSales = new List<SaleRecord>();\n        foreach (var sale in recentSales)\n        {\n            if (sale.Amount > 1000)\n            {\n                largeSales.Add(sale);\n            }\n        }\n        \n        // Ordenar por monto descendente\n        for (int i = 0; i < largeSales.Count - 1; i++)\n        {\n            for (int j = i + 1; j < largeSales.Count; j++)\n            {\n                if (largeSales[i].Amount < largeSales[j].Amount)\n                {\n                    var temp = largeSales[i];\n                    largeSales[i] = largeSales[j];\n                    largeSales[j] = temp;\n                }\n            }\n        }\n        \n        Console.WriteLine($\"\\nVentas grandes (>${1000}): {largeSales.Count}\");\n        foreach (var sale in largeSales)\n        {\n            Console.WriteLine($\"  {sale.CustomerName} - {sale.Product}: ${sale.Amount:N2}\");\n        }\n    }\n    \n    // Datos de ejemplo para testing\n    public static List<SaleRecord> GetSampleData()\n    {\n        return new List<SaleRecord>\n        {\n            new() { Id = 1, CustomerName = \"Juan Pérez\", Product = \"Laptop\", Amount = 1200, SaleDate = DateTime.Now.AddDays(-10), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 2, CustomerName = \"María González\", Product = \"Mouse\", Amount = 50, SaleDate = DateTime.Now.AddDays(-5), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 3, CustomerName = \"Carlos López\", Product = \"Teclado\", Amount = 80, SaleDate = DateTime.Now.AddDays(-15), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 4, CustomerName = \"Ana Martín\", Product = \"Monitor\", Amount = 300, SaleDate = DateTime.Now.AddDays(-20), Region = \"Centro\", SalesPersonId = \"SP003\" },\n            new() { Id = 5, CustomerName = \"Luis Torres\", Product = \"Laptop\", Amount = 1500, SaleDate = DateTime.Now.AddDays(-8), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 6, CustomerName = \"Elena Ruiz\", Product = \"Tablet\", Amount = 400, SaleDate = DateTime.Now.AddDays(-12), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 7, CustomerName = \"Pedro Sánchez\", Product = \"Mouse\", Amount = 45, SaleDate = DateTime.Now.AddDays(-3), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 8, CustomerName = \"Carmen Díaz\", Product = \"Impresora\", Amount = 250, SaleDate = DateTime.Now.AddDays(-18), Region = \"Centro\", SalesPersonId = \"SP003\" },\n            new() { Id = 9, CustomerName = \"Roberto Kim\", Product = \"Laptop\", Amount = 1100, SaleDate = DateTime.Now.AddDays(-6), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 10, CustomerName = \"Isabel Moreno\", Product = \"Teclado\", Amount = 90, SaleDate = DateTime.Now.AddDays(-14), Region = \"Sur\", SalesPersonId = \"SP002\" }\n        };\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        var sales = SalesReportGenerator.GetSampleData();\n        SalesReportGenerator.GenerateReport(sales);\n    }\n}",
    "afterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// CÓDIGO FUNCIONAL - REFACTORIZADO CON LINQ\n// Este código demuestra el poder y elegancia de la programación funcional con LINQ\n\npublic class SaleRecord\n{\n    public int Id { get; set; }\n    public string CustomerName { get; set; } = \"\";\n    public string Product { get; set; } = \"\";\n    public decimal Amount { get; set; }\n    public DateTime SaleDate { get; set; }\n    public string Region { get; set; } = \"\";\n    public string SalesPersonId { get; set; } = \"\";\n}\n\npublic class FunctionalSalesReportGenerator\n{\n    public static void GenerateReport(List<SaleRecord> sales)\n    {\n        Console.WriteLine(\"=== Reporte de Ventas (Código Funcional con LINQ) ===\");\n        \n        var lastMonth = DateTime.Now.AddMonths(-1);\n        \n        // 1. Filtrar ventas del último mes (FUNCIONAL - UNA LÍNEA)\n        var recentSales = sales.Where(s => s.SaleDate >= lastMonth).ToList();\n        Console.WriteLine($\"Ventas del último mes: {recentSales.Count}\");\n        \n        // 2. Calcular total de ventas por región (FUNCIONAL)\n        var salesByRegion = recentSales\n            .GroupBy(s => s.Region)\n            .ToDictionary(g => g.Key, g => g.Sum(s => s.Amount));\n        \n        Console.WriteLine(\"\\nVentas por región:\");\n        salesByRegion.ToList().ForEach(kvp => \n            Console.WriteLine($\"  {kvp.Key}: ${kvp.Value:N2}\"));\n        \n        // 3. Encontrar top 5 productos más vendidos (FUNCIONAL)\n        var topProducts = recentSales\n            .GroupBy(s => s.Product)\n            .Select(g => new { Product = g.Key, Count = g.Count() })\n            .OrderByDescending(p => p.Count)\n            .Take(5);\n        \n        Console.WriteLine(\"\\nTop 5 productos más vendidos:\");\n        topProducts.ToList().ForEach(p => \n            Console.WriteLine($\"  {p.Product}: {p.Count} ventas\"));\n        \n        // 4. Calcular promedio de ventas por vendedor (FUNCIONAL)\n        var averageBySalesPerson = recentSales\n            .GroupBy(s => s.SalesPersonId)\n            .Select(g => new { \n                SalesPersonId = g.Key, \n                AverageAmount = g.Average(s => s.Amount) \n            });\n        \n        Console.WriteLine(\"\\nPromedio de ventas por vendedor:\");\n        averageBySalesPerson.ToList().ForEach(avg => \n            Console.WriteLine($\"  {avg.SalesPersonId}: ${avg.AverageAmount:N2}\"));\n        \n        // 5. Encontrar ventas grandes (>$1000) y ordenar (FUNCIONAL)\n        var largeSales = recentSales\n            .Where(s => s.Amount > 1000)\n            .OrderByDescending(s => s.Amount);\n        \n        Console.WriteLine($\"\\nVentas grandes (>${1000}): {largeSales.Count()}\");\n        largeSales.ToList().ForEach(sale => \n            Console.WriteLine($\"  {sale.CustomerName} - {sale.Product}: ${sale.Amount:N2}\"));\n        \n        // BONUS: Estadísticas adicionales con LINQ avanzado\n        GenerateAdvancedStatistics(recentSales);\n    }\n    \n    private static void GenerateAdvancedStatistics(List<SaleRecord> sales)\n    {\n        Console.WriteLine(\"\\n=== Estadísticas Avanzadas ===\\n\");\n        \n        // Análisis temporal\n        var salesByWeek = sales\n            .GroupBy(s => GetWeekOfYear(s.SaleDate))\n            .Select(g => new { Week = g.Key, Total = g.Sum(s => s.Amount), Count = g.Count() })\n            .OrderBy(w => w.Week);\n        \n        Console.WriteLine(\"Ventas por semana:\");\n        salesByWeek.ToList().ForEach(w => \n            Console.WriteLine($\"  Semana {w.Week}: ${w.Total:N2} ({w.Count} ventas)\"));\n        \n        // Top performers\n        var topPerformers = sales\n            .GroupBy(s => s.SalesPersonId)\n            .Select(g => new {\n                SalesPersonId = g.Key,\n                TotalSales = g.Sum(s => s.Amount),\n                TransactionCount = g.Count(),\n                AverageTransaction = g.Average(s => s.Amount)\n            })\n            .OrderByDescending(p => p.TotalSales)\n            .Take(3);\n        \n        Console.WriteLine(\"\\nTop 3 vendedores:\");\n        topPerformers.ToList().ForEach(p => \n            Console.WriteLine($\"  {p.SalesPersonId}: ${p.TotalSales:N2} ({p.TransactionCount} ventas, avg: ${p.AverageTransaction:N2})\"));\n        \n        // Análisis de productos por región y vendedor\n        var regionProductAnalysis = sales\n            .GroupBy(s => new { s.Region, s.Product })\n            .Where(g => g.Count() > 1) // Solo productos vendidos múltiples veces\n            .Select(g => new {\n                Region = g.Key.Region,\n                Product = g.Key.Product,\n                Count = g.Count(),\n                TotalRevenue = g.Sum(s => s.Amount)\n            })\n            .OrderBy(a => a.Region)\n            .ThenByDescending(a => a.TotalRevenue);\n        \n        Console.WriteLine(\"\\nAnálisis Región-Producto (productos recurrentes):\");\n        regionProductAnalysis.ToList().ForEach(a => \n            Console.WriteLine($\"  {a.Region} - {a.Product}: {a.Count} ventas, ${a.TotalRevenue:N2}\"));\n    }\n    \n    private static int GetWeekOfYear(DateTime date)\n    {\n        var jan1 = new DateTime(date.Year, 1, 1);\n        var daysOffset = (int)jan1.DayOfWeek;\n        var firstWeekDay = jan1.AddDays(-daysOffset);\n        var weekNum = ((date - firstWeekDay).Days / 7) + 1;\n        return weekNum;\n    }\n    \n    // Datos de ejemplo para testing\n    public static List<SaleRecord> GetSampleData()\n    {\n        return new List<SaleRecord>\n        {\n            new() { Id = 1, CustomerName = \"Juan Pérez\", Product = \"Laptop\", Amount = 1200, SaleDate = DateTime.Now.AddDays(-10), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 2, CustomerName = \"María González\", Product = \"Mouse\", Amount = 50, SaleDate = DateTime.Now.AddDays(-5), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 3, CustomerName = \"Carlos López\", Product = \"Teclado\", Amount = 80, SaleDate = DateTime.Now.AddDays(-15), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 4, CustomerName = \"Ana Martín\", Product = \"Monitor\", Amount = 300, SaleDate = DateTime.Now.AddDays(-20), Region = \"Centro\", SalesPersonId = \"SP003\" },\n            new() { Id = 5, CustomerName = \"Luis Torres\", Product = \"Laptop\", Amount = 1500, SaleDate = DateTime.Now.AddDays(-8), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 6, CustomerName = \"Elena Ruiz\", Product = \"Tablet\", Amount = 400, SaleDate = DateTime.Now.AddDays(-12), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 7, CustomerName = \"Pedro Sánchez\", Product = \"Mouse\", Amount = 45, SaleDate = DateTime.Now.AddDays(-3), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 8, CustomerName = \"Carmen Díaz\", Product = \"Impresora\", Amount = 250, SaleDate = DateTime.Now.AddDays(-18), Region = \"Centro\", SalesPersonId = \"SP003\" },\n            new() { Id = 9, CustomerName = \"Roberto Kim\", Product = \"Laptop\", Amount = 1100, SaleDate = DateTime.Now.AddDays(-6), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 10, CustomerName = \"Isabel Moreno\", Product = \"Teclado\", Amount = 90, SaleDate = DateTime.Now.AddDays(-14), Region = \"Sur\", SalesPersonId = \"SP002\" }\n        };\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        var sales = FunctionalSalesReportGenerator.GetSampleData();\n        FunctionalSalesReportGenerator.GenerateReport(sales);\n        \n        Console.WriteLine(\"\\n\" + \"=\".PadRight(50, '='));\n        Console.WriteLine(\"COMPARACIÓN: Código funcional vs imperativo completada.\");\n        Console.WriteLine(\"Nota: El código funcional es más conciso, legible y expresivo.\");\n    }\n}",
    "starterTemplate": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n// TODO: Refactorizar este código imperativo usando LINQ\n// Enfócate en eliminar bucles manuales y usar operaciones funcionales\n\npublic class SaleRecord\n{\n    public int Id { get; set; }\n    public string CustomerName { get; set; } = \"\";\n    public string Product { get; set; } = \"\";\n    public decimal Amount { get; set; }\n    public DateTime SaleDate { get; set; }\n    public string Region { get; set; } = \"\";\n    public string SalesPersonId { get; set; } = \"\";\n}\n\npublic class SalesReportGenerator\n{\n    public static void GenerateReport(List<SaleRecord> sales)\n    {\n        Console.WriteLine(\"=== Reporte de Ventas ===\\n\");\n        \n        var lastMonth = DateTime.Now.AddMonths(-1);\n        \n        // TODO #1: Convertir este filtrado imperativo a una operación LINQ\n        List<SaleRecord> recentSales = new List<SaleRecord>();\n        foreach (var sale in sales)\n        {\n            if (sale.SaleDate >= lastMonth)\n            {\n                recentSales.Add(sale);\n            }\n        }\n        // LINQ: var recentSales = sales.Where(s => s.SaleDate >= lastMonth).ToList();\n        \n        Console.WriteLine($\"Ventas del último mes: {recentSales.Count}\");\n        \n        // TODO #2: Convertir este agrupamiento manual a GroupBy + ToDictionary\n        Dictionary<string, decimal> salesByRegion = new Dictionary<string, decimal>();\n        foreach (var sale in recentSales)\n        {\n            if (salesByRegion.ContainsKey(sale.Region))\n            {\n                salesByRegion[sale.Region] += sale.Amount;\n            }\n            else\n            {\n                salesByRegion[sale.Region] = sale.Amount;\n            }\n        }\n        // LINQ: var salesByRegion = recentSales.GroupBy(s => s.Region).ToDictionary(g => g.Key, g => g.Sum(s => s.Amount));\n        \n        Console.WriteLine(\"\\nVentas por región:\");\n        // TODO #3: Usar ForEach o foreach simple en lugar de bucle manual\n        foreach (var kvp in salesByRegion)\n        {\n            Console.WriteLine($\"  {kvp.Key}: ${kvp.Value:N2}\");\n        }\n        \n        // TODO #4: Convertir conteo + ordenamiento manual a GroupBy + OrderBy + Take\n        Dictionary<string, int> productCounts = new Dictionary<string, int>();\n        foreach (var sale in recentSales)\n        {\n            if (productCounts.ContainsKey(sale.Product))\n            {\n                productCounts[sale.Product]++;\n            }\n            else\n            {\n                productCounts[sale.Product] = 1;\n            }\n        }\n        \n        // Reemplazar bubble sort con OrderByDescending\n        List<KeyValuePair<string, int>> sortedProducts = new List<KeyValuePair<string, int>>();\n        foreach (var kvp in productCounts)\n        {\n            sortedProducts.Add(kvp);\n        }\n        \n        for (int i = 0; i < sortedProducts.Count - 1; i++)\n        {\n            for (int j = 0; j < sortedProducts.Count - i - 1; j++)\n            {\n                if (sortedProducts[j].Value < sortedProducts[j + 1].Value)\n                {\n                    var temp = sortedProducts[j];\n                    sortedProducts[j] = sortedProducts[j + 1];\n                    sortedProducts[j + 1] = temp;\n                }\n            }\n        }\n        \n        Console.WriteLine(\"\\nTop 5 productos más vendidos:\");\n        int count = 0;\n        foreach (var product in sortedProducts)\n        {\n            if (count >= 5) break;\n            Console.WriteLine($\"  {product.Key}: {product.Value} ventas\");\n            count++;\n        }\n        \n        // TODO #5: Usar GroupBy + Select + Average en lugar de agrupamiento manual\n        Dictionary<string, List<decimal>> salesBySalesPerson = new Dictionary<string, List<decimal>>();\n        foreach (var sale in recentSales)\n        {\n            if (!salesBySalesPerson.ContainsKey(sale.SalesPersonId))\n            {\n                salesBySalesPerson[sale.SalesPersonId] = new List<decimal>();\n            }\n            salesBySalesPerson[sale.SalesPersonId].Add(sale.Amount);\n        }\n        \n        Console.WriteLine(\"\\nPromedio de ventas por vendedor:\");\n        foreach (var kvp in salesBySalesPerson)\n        {\n            decimal total = 0;\n            int count2 = 0;\n            foreach (var amount in kvp.Value)\n            {\n                total += amount;\n                count2++;\n            }\n            decimal average = count2 > 0 ? total / count2 : 0;\n            Console.WriteLine($\"  {kvp.Key}: ${average:N2}\");\n        }\n        \n        // TODO #6: Usar Where + OrderByDescending en lugar de filtrado + ordenamiento manual\n        List<SaleRecord> largeSales = new List<SaleRecord>();\n        foreach (var sale in recentSales)\n        {\n            if (sale.Amount > 1000)\n            {\n                largeSales.Add(sale);\n            }\n        }\n        \n        for (int i = 0; i < largeSales.Count - 1; i++)\n        {\n            for (int j = i + 1; j < largeSales.Count; j++)\n            {\n                if (largeSales[i].Amount < largeSales[j].Amount)\n                {\n                    var temp = largeSales[i];\n                    largeSales[i] = largeSales[j];\n                    largeSales[j] = temp;\n                }\n            }\n        }\n        \n        Console.WriteLine($\"\\nVentas grandes (>${1000}): {largeSales.Count}\");\n        foreach (var sale in largeSales)\n        {\n            Console.WriteLine($\"  {sale.CustomerName} - {sale.Product}: ${sale.Amount:N2}\");\n        }\n    }\n    \n    public static List<SaleRecord> GetSampleData()\n    {\n        return new List<SaleRecord>\n        {\n            new() { Id = 1, CustomerName = \"Juan Pérez\", Product = \"Laptop\", Amount = 1200, SaleDate = DateTime.Now.AddDays(-10), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 2, CustomerName = \"María González\", Product = \"Mouse\", Amount = 50, SaleDate = DateTime.Now.AddDays(-5), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 3, CustomerName = \"Carlos López\", Product = \"Teclado\", Amount = 80, SaleDate = DateTime.Now.AddDays(-15), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 4, CustomerName = \"Ana Martín\", Product = \"Monitor\", Amount = 300, SaleDate = DateTime.Now.AddDays(-20), Region = \"Centro\", SalesPersonId = \"SP003\" },\n            new() { Id = 5, CustomerName = \"Luis Torres\", Product = \"Laptop\", Amount = 1500, SaleDate = DateTime.Now.AddDays(-8), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 6, CustomerName = \"Elena Ruiz\", Product = \"Tablet\", Amount = 400, SaleDate = DateTime.Now.AddDays(-12), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 7, CustomerName = \"Pedro Sánchez\", Product = \"Mouse\", Amount = 45, SaleDate = DateTime.Now.AddDays(-3), Region = \"Sur\", SalesPersonId = \"SP002\" },\n            new() { Id = 8, CustomerName = \"Carmen Díaz\", Product = \"Impresora\", Amount = 250, SaleDate = DateTime.Now.AddDays(-18), Region = \"Centro\", SalesPersonId = \"SP003\" },\n            new() { Id = 9, CustomerName = \"Roberto Kim\", Product = \"Laptop\", Amount = 1100, SaleDate = DateTime.Now.AddDays(-6), Region = \"Norte\", SalesPersonId = \"SP001\" },\n            new() { Id = 10, CustomerName = \"Isabel Moreno\", Product = \"Teclado\", Amount = 90, SaleDate = DateTime.Now.AddDays(-14), Region = \"Sur\", SalesPersonId = \"SP002\" }\n        };\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        var sales = SalesReportGenerator.GetSampleData();\n        SalesReportGenerator.GenerateReport(sales);\n    }\n}",
    "unitTests": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Xunit;\n\nnamespace SalesReport.Tests\n{\n    /// <summary>\n    /// Tests para verificar que el código refactorizado mantiene la misma funcionalidad\n    /// </summary>\n    public class FunctionalRefactoringTests\n    {\n        private readonly List<SaleRecord> _testData;\n        \n        public FunctionalRefactoringTests()\n        {\n            _testData = new List<SaleRecord>\n            {\n                new() { Id = 1, CustomerName = \"Test1\", Product = \"Laptop\", Amount = 1200, SaleDate = DateTime.Now.AddDays(-5), Region = \"Norte\", SalesPersonId = \"SP001\" },\n                new() { Id = 2, CustomerName = \"Test2\", Product = \"Mouse\", Amount = 50, SaleDate = DateTime.Now.AddDays(-10), Region = \"Sur\", SalesPersonId = \"SP002\" },\n                new() { Id = 3, CustomerName = \"Test3\", Product = \"Laptop\", Amount = 1500, SaleDate = DateTime.Now.AddDays(-15), Region = \"Norte\", SalesPersonId = \"SP001\" },\n                new() { Id = 4, CustomerName = \"Test4\", Product = \"Teclado\", Amount = 80, SaleDate = DateTime.Now.AddDays(-35), Region = \"Centro\", SalesPersonId = \"SP003\" }, // Fuera del rango\n                new() { Id = 5, CustomerName = \"Test5\", Product = \"Monitor\", Amount = 300, SaleDate = DateTime.Now.AddDays(-8), Region = \"Sur\", SalesPersonId = \"SP002\" }\n            };\n        }\n        \n        [Fact]\n        public void FilterRecentSales_ImperativeVsFunctional_ShouldReturnSameResults()\n        {\n            var lastMonth = DateTime.Now.AddMonths(-1);\n            \n            // Imperativo\n            List<SaleRecord> imperativeResult = new List<SaleRecord>();\n            foreach (var sale in _testData)\n            {\n                if (sale.SaleDate >= lastMonth)\n                {\n                    imperativeResult.Add(sale);\n                }\n            }\n            \n            // Funcional\n            var functionalResult = _testData.Where(s => s.SaleDate >= lastMonth).ToList();\n            \n            // Verificar\n            Assert.Equal(imperativeResult.Count, functionalResult.Count);\n            Assert.True(imperativeResult.Select(s => s.Id).SequenceEqual(functionalResult.Select(s => s.Id)));\n        }\n        \n        [Fact]\n        public void GroupSalesByRegion_ImperativeVsFunctional_ShouldReturnSameResults()\n        {\n            var recentSales = _testData.Where(s => s.SaleDate >= DateTime.Now.AddMonths(-1)).ToList();\n            \n            // Imperativo\n            Dictionary<string, decimal> imperativeResult = new Dictionary<string, decimal>();\n            foreach (var sale in recentSales)\n            {\n                if (imperativeResult.ContainsKey(sale.Region))\n                {\n                    imperativeResult[sale.Region] += sale.Amount;\n                }\n                else\n                {\n                    imperativeResult[sale.Region] = sale.Amount;\n                }\n            }\n            \n            // Funcional\n            var functionalResult = recentSales\n                .GroupBy(s => s.Region)\n                .ToDictionary(g => g.Key, g => g.Sum(s => s.Amount));\n            \n            // Verificar\n            Assert.Equal(imperativeResult.Count, functionalResult.Count);\n            foreach (var kvp in imperativeResult)\n            {\n                Assert.True(functionalResult.ContainsKey(kvp.Key));\n                Assert.Equal(kvp.Value, functionalResult[kvp.Key]);\n            }\n        }\n        \n        [Fact]\n        public void TopProducts_ImperativeVsFunctional_ShouldReturnSameResults()\n        {\n            var recentSales = _testData.Where(s => s.SaleDate >= DateTime.Now.AddMonths(-1)).ToList();\n            \n            // Imperativo (simplificado para test)\n            Dictionary<string, int> productCounts = new Dictionary<string, int>();\n            foreach (var sale in recentSales)\n            {\n                if (productCounts.ContainsKey(sale.Product))\n                {\n                    productCounts[sale.Product]++;\n                }\n                else\n                {\n                    productCounts[sale.Product] = 1;\n                }\n            }\n            var imperativeResult = productCounts.OrderByDescending(kvp => kvp.Value).Take(5).ToList();\n            \n            // Funcional\n            var functionalResult = recentSales\n                .GroupBy(s => s.Product)\n                .Select(g => new { Product = g.Key, Count = g.Count() })\n                .OrderByDescending(p => p.Count)\n                .Take(5)\n                .Select(p => new KeyValuePair<string, int>(p.Product, p.Count))\n                .ToList();\n            \n            // Verificar\n            Assert.Equal(imperativeResult.Count, functionalResult.Count);\n            for (int i = 0; i < imperativeResult.Count; i++)\n            {\n                Assert.Equal(imperativeResult[i].Key, functionalResult[i].Key);\n                Assert.Equal(imperativeResult[i].Value, functionalResult[i].Value);\n            }\n        }\n        \n        [Fact]\n        public void AverageBySalesPerson_ImperativeVsFunctional_ShouldReturnSameResults()\n        {\n            var recentSales = _testData.Where(s => s.SaleDate >= DateTime.Now.AddMonths(-1)).ToList();\n            \n            // Imperativo\n            Dictionary<string, List<decimal>> salesBySalesPerson = new Dictionary<string, List<decimal>>();\n            foreach (var sale in recentSales)\n            {\n                if (!salesBySalesPerson.ContainsKey(sale.SalesPersonId))\n                {\n                    salesBySalesPerson[sale.SalesPersonId] = new List<decimal>();\n                }\n                salesBySalesPerson[sale.SalesPersonId].Add(sale.Amount);\n            }\n            \n            var imperativeResult = new Dictionary<string, decimal>();\n            foreach (var kvp in salesBySalesPerson)\n            {\n                decimal total = 0;\n                int count = 0;\n                foreach (var amount in kvp.Value)\n                {\n                    total += amount;\n                    count++;\n                }\n                decimal average = count > 0 ? total / count : 0;\n                imperativeResult[kvp.Key] = average;\n            }\n            \n            // Funcional\n            var functionalResult = recentSales\n                .GroupBy(s => s.SalesPersonId)\n                .ToDictionary(g => g.Key, g => g.Average(s => s.Amount));\n            \n            // Verificar\n            Assert.Equal(imperativeResult.Count, functionalResult.Count);\n            foreach (var kvp in imperativeResult)\n            {\n                Assert.True(functionalResult.ContainsKey(kvp.Key));\n                Assert.Equal(kvp.Value, functionalResult[kvp.Key], 2); // 2 decimales de precisión\n            }\n        }\n        \n        [Fact]\n        public void LargeSalesFilter_ImperativeVsFunctional_ShouldReturnSameResults()\n        {\n            var recentSales = _testData.Where(s => s.SaleDate >= DateTime.Now.AddMonths(-1)).ToList();\n            const decimal threshold = 1000;\n            \n            // Imperativo\n            List<SaleRecord> imperativeResult = new List<SaleRecord>();\n            foreach (var sale in recentSales)\n            {\n                if (sale.Amount > threshold)\n                {\n                    imperativeResult.Add(sale);\n                }\n            }\n            imperativeResult = imperativeResult.OrderByDescending(s => s.Amount).ToList();\n            \n            // Funcional\n            var functionalResult = recentSales\n                .Where(s => s.Amount > threshold)\n                .OrderByDescending(s => s.Amount)\n                .ToList();\n            \n            // Verificar\n            Assert.Equal(imperativeResult.Count, functionalResult.Count);\n            Assert.True(imperativeResult.Select(s => s.Id).SequenceEqual(functionalResult.Select(s => s.Id)));\n        }\n        \n        [Fact]\n        public void LinqChaining_ShouldNotEnumerateMultipleTimes()\n        {\n            // Test para verificar que no hay múltiples enumeraciones\n            var query = _testData\n                .Where(s => s.SaleDate >= DateTime.Now.AddMonths(-1))\n                .Where(s => s.Amount > 100); // Cadena de operaciones\n            \n            // Enumerar solo una vez al final\n            var results = query.ToList();\n            \n            Assert.True(results.All(s => s.SaleDate >= DateTime.Now.AddMonths(-1)));\n            Assert.True(results.All(s => s.Amount > 100));\n        }\n        \n        [Theory]\n        [InlineData(0)]\n        [InlineData(500)]\n        [InlineData(1000)]\n        [InlineData(2000)]\n        public void FilterByAmount_ShouldHandleDifferentThresholds(decimal threshold)\n        {\n            var result = _testData\n                .Where(s => s.Amount > threshold)\n                .OrderByDescending(s => s.Amount)\n                .ToList();\n            \n            Assert.True(result.All(s => s.Amount > threshold));\n            Assert.True(result.SequenceEqual(result.OrderByDescending(s => s.Amount)));\n        }\n    }\n}",
    "projectFile": "<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.8.0\" />\n    <PackageReference Include=\"xunit\" Version=\"2.6.1\" />\n    <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.5.3\" />\n  </ItemGroup>\n\n</Project>"
  },
  "extensions": [
    "Implementar más operaciones LINQ avanzadas como Join, SelectMany, Zip",
    "Agregar análisis de performance comparando tiempos de ejecución",
    "Crear versión asíncrona usando PLINQ para procesamiento paralelo",
    "Implementar lazy evaluation con IEnumerable en lugar de ToList() prematuro",
    "Agregar validación de null usando operadores de null-coalescing",
    "Crear custom extension methods para operaciones específicas del dominio"
  ],
  "pedagogical": {
    "keyConcepts": [
      "Programación funcional vs imperativa",
      "Métodos LINQ fundamentales (Where, Select, GroupBy, OrderBy)",
      "Evaluación perezosa (lazy evaluation) vs evaluación inmediata",
      "Expresiones lambda y delegates",
      "Método chaining y fluent interfaces",
      "Optimización de consultas y evitar múltiples enumeraciones"
    ],
    "commonPitfalls": [
      "Enumerar IEnumerable múltiples veces (llamar ToList() muy temprano)",
      "Usar bucles cuando LINQ sería más apropiado y legible",
      "No entender cuándo se ejecutan las consultas LINQ (deferred execution)",
      "Crear consultas LINQ innecesariamente complejas cuando lógica simple sería mejor",
      "No manejar casos edge como colecciones vacías o valores null",
      "Usar LINQ para operaciones que requieren efectos secundarios (ForEach con acciones)"
    ],
    "explanation": "Este ejercicio demuestra la transición de programación imperativa tradicional hacia programación funcional usando LINQ. El código imperativo usa bucles explícitos, variables temporales y lógica de control manual, mientras que el código funcional utiliza operaciones declarativas que expresan QUÉ se quiere lograr en lugar de CÓMO hacerlo. LINQ proporciona métodos como Where para filtrado, Select para transformación, GroupBy para agrupamiento, y OrderBy para ordenamiento, resultando en código más conciso, legible y menos propenso a errores.",
    "teachingTips": [
      "Mostrar side-by-side el código imperativo y funcional para destacar las diferencias",
      "Explicar que LINQ no siempre es mejor - a veces bucles simples son más claros",
      "Demostrar cómo debuggear consultas LINQ complejas dividiéndolas en pasos",
      "Enfatizar la importancia de entender cuándo se ejecutan las consultas LINQ",
      "Mostrar herramientas como LINQPad para experimentar con consultas LINQ"
    ],
    "relatedConcepts": [
      "Delegates y expresiones lambda",
      "Interfaces IEnumerable e IQueryable",
      "Extension methods y method chaining",
      "Programación funcional en C#",
      "Performance y optimización de consultas",
      "PLINQ para procesamiento paralelo"
    ],
    "furtherReading": [
      "Microsoft LINQ Documentation and Best Practices",
      "Jon Skeet's C# in Depth - LINQ chapters",
      "Effective C# by Bill Wagner - LINQ items",
      "LINQPad tool for interactive LINQ experimentation",
      "Performance considerations in LINQ queries"
    ]
  }
}