Curso Práctico de Indexación para SQL y EF CoreDe Cero a Héroe del RendimientoIntroducción: ¿Por Qué un Índice es Como el Índice de un Libro?¿Alguna vez has visto cómo los usuarios abandonan un carrito de compras porque la página tarda una eternidad en cargar? ¿O cómo un reporte interno que debería tomar segundos paraliza la aplicación por minutos? La causa raíz de estos problemas costosos suele ser la misma: una estrategia de indexación deficiente. Un índice en una base de datos es la diferencia entre una búsqueda frustrantemente lenta y una respuesta instantánea.Leer el libro página por página (Table Scan): Lento, ineficiente y tedioso.Ir al índice al principio del libro (Index Seek): Encuentras "Revolución Francesa", te dice que empieza en la página 210 y vas directamente allí. Rápido y preciso.Un índice en una base de datos funciona exactamente igual. Es una estructura de datos separada que contiene una copia de una o más columnas de una tabla, ordenadas de una manera específica, con un "puntero" a la fila completa de datos. Sin un índice, cuando haces WHERE Email = 'juan@test.com', SQL Server debe, en el peor de los casos, leer cada una de las filas de la tabla para encontrar la que buscas. Con un índice en la columna Email, lo encuentra casi instantáneamente.Clase 1: Los Fundamentos - Clustered vs. Non-ClusteredObjetivos:Entender la diferencia fundamental entre un índice Clustered y uno Non-Clustered.Crear índices simples en SQL y con EF Core.Visualizar el impacto de un índice en un plan de ejecución.Paso 1: La Estructura de la Tabla - Índice Clustered (Agrupado)Toda tabla solo puede tener un índice Clustered. ¿Por qué? Porque el índice Clustered es la tabla misma, ordenada físicamente en el disco según las columnas de este índice.Cuando creas una PRIMARY KEY en una tabla, SQL Server automáticamente crea un índice Clustered único sobre esa columna.Piénsalo como una guía telefónica ordenada alfabéticamente por apellido. El apellido es el índice Clustered y los datos están físicamente ordenados de esa manera.Paso 2: El Índice del Libro - Índice Non-Clustered (No Agrupado)Puedes tener muchos índices Non-Clustered en una tabla (hasta 999).Estos son estructuras separadas que contienen las columnas del índice y un "puntero" (llamado Row Locator) que le dice a SQL dónde encontrar la fila completa en la tabla principal (en el índice Clustered).Siguiendo la analogía, sería como tener un índice por tema al final del libro de historia, además del índice de contenidos principal.Paso 3: Creación Paso a PasoEscenario: Tenemos una tabla Products con millones de productos. Frecuentemente buscamos productos por su código SKU.SQL:CREATE TABLE Products (
    ProductID INT PRIMARY KEY, -- Esto crea un índice Clustered en ProductID
    ProductName NVARCHAR(200),
    SKU NVARCHAR(50) NOT NULL,
    Price DECIMAL(10, 2)
);

-- La consulta LENTA sin el índice Non-Clustered
-- SQL Server tiene que hacer un "Clustered Index Scan" (leer toda la tabla)
SELECT ProductName, Price FROM Products WHERE SKU = 'ABC-12345';

-- CREAMOS EL ÍNDICE
CREATE NONCLUSTERED INDEX IX_Products_SKU ON Products(SKU);

-- La consulta RÁPIDA con el índice
-- SQL Server ahora hace un "Index Seek" (búsqueda precisa) en nuestro nuevo índice.
SELECT ProductName, Price FROM Products WHERE SKU = 'ABC-12345';


Entity Framework Core: Cuando escribes una consulta LINQ como: var product = await context.Products.FirstOrDefaultAsync(p => p.Sku == "ABC-12345");, EF Core la traduce a una sentencia SQL con WHERE SKU = 'ABC-12345'. Gracias al índice IX_Products_SKU que definimos, esta operación se convierte en un Index Seek ultra rápido en lugar de un Table Scan lento.// En tu DbContext, dentro de OnModelCreating
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Product>(entity =>
    {
        entity.HasKey(p => p.ProductId); // EF Core sabe que esto será el índice Clustered

        // Aquí definimos nuestro índice Non-Clustered
        entity.HasIndex(p => p.Sku, "IX_Products_SKU");
    });
}


Ejercicio Propuesto 1Tienes una tabla Users con millones de usuarios. La operación más común es el login, que busca un usuario por su Email.Escribe la sentencia CREATE TABLE para la tabla Users (UserID PK, Email, PasswordHash, CreatedAt).Escribe una consulta de SELECT que simule la búsqueda por email.Escribe la sentencia CREATE INDEX para crear el índice que optimizará drásticamente esa consulta.Clase 2: El Arte del Orden - Índices CompuestosObjetivos:Diseñar índices con múltiples columnas (compuestos).Entender por qué el orden de las columnas en el índice es lo más importante.Aprender el concepto de selectividad.Paso 1: La Regla de Oro del Orden de las ColumnasImagina que tienes una guía telefónica (¡de nuevo!) con millones de personas de todo el país. Quieres buscar a "Juan Pérez" en "Mendoza".Opción A (Mal Orden): La guía está ordenada por Nombre, luego por Apellido, luego por Provincia. Para encontrar a los "Pérez", tienes que buscar en todas las J de "Juan" del país. Ineficiente.Opción B (Buen Orden): La guía está ordenada por Provincia, luego por Apellido, luego por Nombre. Vas directamente a la sección "Mendoza", luego a la P de "Pérez", y finalmente buscas a "Juan". Extremadamente eficiente.Principio: Un índice en (ColA, ColB, ColC) puede ser usado eficientemente por consultas que filtran por:ColAColA y ColBColA, ColB y ColCPero NO puede ser usado eficientemente por consultas que filtran solo por ColB o solo por ColC. Debes usar la columna de más a la izquierda primero.Paso 2: Selectividad - El Arte de Filtrar MejorSelectividad se refiere a cuán únicos son los valores en una columna. Una columna con alta selectividad tiene muchos valores únicos (como un Email o un DNI). Una columna con baja selectividad tiene pocos valores únicos (como un Status con valores 'Activo'/'Inactivo', o un Género).Principio de Diseño: Al crear un índice compuesto, coloca primero la columna con la mayor selectividad (la que reduce más el conjunto de resultados).Escenario: Tabla de Invoices con filtros por CustomerID (alta selectividad) y Status (baja selectividad, ej: 'Pendiente', 'Pagada', 'Cancelada')).Consulta Frecuente:SELECT InvoiceID, Amount FROM Invoices WHERE CustomerID = @customer AND Status = 'Pendiente';Índice MALO: CREATE INDEX IX_Invoices_Status_Customer ON Invoices(Status, CustomerID);SQL primero tiene que leer 10 millones de filas para encontrar todas las facturas 'Pendientes' y luego, dentro de ese grupo gigante, buscar las 5 facturas del cliente. Por el contrario, con el índice BUENO, SQL primero busca las 5 facturas del CustomerID y luego, dentro de ese grupo diminuto, encuentra la que está 'Pendiente'. La diferencia en el trabajo realizado es de órdenes de magnitud.Índice BUENO: CREATE INDEX IX_Invoices_Customer_Status ON Invoices(CustomerID, Status);SQL primero encuentra las pocas facturas del CustomerID y luego, dentro de ese grupo pequeño, filtra las 'Pendientes'.Ejercicio Propuesto 2Tienes una tienda online. La búsqueda más común en la página de productos es por CategoryID y Brand. También se puede buscar solo por CategoryID. Los datos muestran que hay 50 categorías y 2000 marcas.¿Qué columna tiene mayor selectividad, CategoryID o Brand?Escribe la sentencia CREATE INDEX óptima para la tabla Products para servir a estas búsquedas. Justifica el orden de las columnas que elegiste.Clase 3: Optimizando el ORDER BY y los Índices de CoberturaObjetivos:Entender cómo los índices pueden eliminar operaciones de ordenamiento (Sort) costosas.Aprender a crear "Índices de Cobertura" (Covering Indexes) para un rendimiento máximo.Paso 1: Evitando el "Costly Sort"Los datos en un índice ya están ordenados según las columnas que lo componen. Si tu consulta pide los datos en el mismo orden (ORDER BY), SQL Server puede simplemente leer el índice en secuencia, lo cual es muy rápido. Si no, tiene que obtener los datos y luego realizar una operación de "Sort" en memoria o en disco, lo cual es muy lento.Escenario: Quieres mostrar las últimas órdenes de un cliente.Consulta: SELECT OrderID, OrderDate, Amount FROM Orders WHERE CustomerID = @customer ORDER BY OrderDate DESC;Índice Aceptable: CREATE INDEX IX_Orders_Customer ON Orders(CustomerID);Esto acelera el WHERE, pero SQL aún debe obtener todas las órdenes del cliente y luego ordenarlas por fecha. El plan de ejecución mostrará un Sort.Índice ÓPTIMO: CREATE INDEX IX_Orders_Customer_Date ON Orders(CustomerID, OrderDate DESC);Este índice coincide perfectamente con el WHERE y el ORDER BY. SQL encuentra al cliente y simplemente lee las órdenes en el orden en que ya están almacenadas en el índice. La operación Sort desaparece del plan de ejecución.Paso 2: El Santo Grial - Covering IndexesNormalmente, después de usar un índice Non-Clustered para encontrar las filas (Index Seek), SQL tiene que hacer un paso extra: ir a la tabla principal para buscar las columnas que no estaban en el índice (un "Key Lookup"). Este paso extra tiene un costo.Un índice de cobertura es un índice Non-Clustered que contiene todas las columnas que la consulta necesita. De esta manera, SQL puede responder la pregunta usando solo el índice, sin tocar la tabla principal en absoluto.Escenario: Una consulta para un dashboard que muestra el título y la fecha de los últimos posts de un blog.Consulta: SELECT Title, CreatedAt FROM BlogPosts WHERE Status = 'Published' ORDER BY CreatedAt DESC;Índice Bueno: CREATE INDEX IX_Blog_Status_Date ON BlogPosts(Status, CreatedAt DESC);Acelera el WHERE y el ORDER BY, pero SQL todavía necesita hacer un "Key Lookup" para obtener el Title de cada fila.Índice de COBERTURA (ÓPTIMO):CREATE NONCLUSTERED INDEX IX_Blog_Covering_Dashboard
ON BlogPosts(Status, CreatedAt DESC)
INCLUDE (Title); -- ¡La magia está aquí!


Buena Práctica: La cláusula INCLUDE es poderosa, pero úsala con prudencia. Incluir demasiadas columnas, o columnas muy grandes (como NVARCHAR(MAX)), puede hacer que tu índice non-clustered sea tan grande como la tabla misma, perdiendo los beneficios de rendimiento y consumiendo mucho espacio en disco. Idealmente, úsala para incluir columnas pequeñas y evitar el "Key Lookup".EF Core:modelBuilder.Entity<BlogPost>()
    .HasIndex(p => new { p.Status, p.CreatedAt })
    .IncludeProperties(p => p.Title) // Así se define el INCLUDE
    .HasDatabaseName("IX_Blog_Covering_Dashboard");


Ejercicio Propuesto 3Diseña el índice de cobertura óptimo para la siguiente consulta frecuente en una tabla Employees.SELECT FirstName, LastName, Email
FROM Employees
WHERE DepartmentID = @deptId AND IsActive = 1
ORDER BY LastName, FirstName;


Clase 4: Detección y MantenimientoObjetivos:Aprender a usar los Planes de Ejecución para detectar índices faltantes.Conocer las Vistas de Gestión Dinámica (DMV) de SQL Server.Entender la importancia del mantenimiento de índices.Paso 1: El Soplón - El Plan de EjecuciónLa herramienta más importante para un desarrollador de bases de datos es el Plan de Ejecución (Execution Plan). En SQL Server Management Studio (SSMS), puedes activarlo antes de ejecutar una consulta.[Imagen de un Plan de Ejecución de SQL mostrando un "Table Scan" costoso]Si ejecutas una consulta lenta y el plan muestra un "Table Scan" o "Clustered Index Scan" con un costo alto (ej. > 90%), significa que SQL está leyendo toda la tabla. ¡Es una señal de alarma de que falta un índice!Mejor aún, a menudo el plan de ejecución te sugerirá un índice. Verás un texto en verde que dice: "Missing Index (...)". Puedes hacer clic derecho y pedirle a SSMS que te genere el CREATE INDEX script. ¡No lo apliques a ciegas! Usa tu conocimiento de las clases anteriores para verificar si el orden de las columnas es el correcto para tu carga de trabajo general.Paso 2: SQL Server como Tu Asistente (DMVs)SQL Server registra internamente información sobre los índices que echa en falta. Puedes consultarla con Vistas de Gestión Dinámica (DMV).Consulta para encontrar los índices más necesitados:SELECT
    migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) AS improvement_measure,
    'CREATE INDEX [missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' + CONVERT (varchar, mid.index_handle)
    + ']' ON ' + mid.statement + ' (' + ISNULL (mid.equality_columns,'')
    + CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ',' ELSE '' END
    + ISNULL (mid.inequality_columns, '')
    + ')' + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement
FROM sys.dm_db_missing_index_groups mig
INNER JOIN sys.dm_db_missing_index_group_stats migs ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details mid ON mig.index_handle = mid.index_handle
ORDER BY improvement_measure DESC;


Esta consulta te dará una lista de sentencias CREATE INDEX para los índices que SQL Server considera que tendrían el mayor impacto positivo en el rendimiento.Paso 3: No Te Olvides de la Limpieza (Mantenimiento)Con el tiempo y después de muchos INSERT, UPDATE y DELETE, los índices se fragmentan. Esto significa que el orden físico de las páginas del índice en el disco ya no es secuencial, lo que ralentiza las lecturas.Fragmentación: Se debe revisar periódicamente.REORGANIZE: Es una operación ligera que "limpia" la fragmentación. Se puede hacer en línea.REBUILD: Guía Rápida: Si la fragmentación es > 5% pero < 30%, considera usar ALTER INDEX ... REORGANIZE. Si es > 30%, un ALTER INDEX ... REBUILD suele ser más efectivo. Puedes revisar la fragmentación con una consulta como: SELECT dbschemas.name as 'Schema', ... FROM sys.dm_db_index_physical_stats ... y proporcionar el script completo.Buenas Prácticas FinalesNo sobre-indexar: Cada índice ralentiza las operaciones de escritura (INSERT, UPDATE, DELETE). Solo crea los índices que realmente necesitas.Índices en claves foráneas (Foreign Keys): Casi siempre es una buena idea crear índices en las columnas de FK, ya que son muy usadas en los JOINs.Mantén tus estadísticas actualizadas: SQL Server usa estadísticas sobre la distribución de datos para elegir el mejor índice. Asegúrate de que estén al día.Mide, no adivines: Usa el Plan de Ejecución y las DMVs para tomar decisiones basadas en datos.